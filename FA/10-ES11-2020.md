# سوالات ES11 - 2020

## ویژگی BigInt

### 1. چرا `BigInt` به جاوا اسکریپت اضافه شد و چه کاربردهایی داره؟
نوع داده‌ی `BigInt` به جاوا اسکریپت اضافه شد تا بتونی با اعداد صحیح خیلی بزرگ کار کنی بدون اینکه دقت محاسبات از دست بره. این نوع داده به خصوص وقتی مفید هست که نیاز داری با اعداد خیلی بزرگتر از محدوده‌ی `Number` که از `64-bit` استفاده می‌کنه، سروکار داشته باشی. `BigInt` این امکان رو فراهم می‌کنه که اعداد بزرگتر از ۲^۵۳-۱ (بزرگترین عدد صحیح قابل نمایش در `Number`) رو به دقت مدیریت کنی.

```javascript
const bigNumber = BigInt(9007199254740991);
const anotherBigNumber = 9007199254740991n; // با اضافه کردن n به آخر عدد هم می‌تونی BigInt ایجاد کنی
console.log(bigNumber + anotherBigNumber); // 18014398509481982n
```

در این مثال، دو عدد بزرگ با استفاده از `BigInt` تعریف شدند و بدون از دست رفتن دقت، با هم جمع شدند. این قابلیت برای انجام محاسبات مالی یا علمی که نیاز به اعداد بسیار بزرگ دارند، بسیار مفید است.

## متد String.prototype.matchAll

### 2. متد `matchAll` چه مشکلاتی رو حل می‌کنه و چطور می‌تونی ازش استفاده کنی؟
متد `matchAll` به جاوا اسکریپت اضافه شد تا بتونی همه‌ی تطبیق‌های یه عبارت منظم رو در یک رشته پیدا کنی و اطلاعات دقیقی از اون‌ها بگیری. قبلاً برای انجام این کار، باید از روش‌های پیچیده‌تر یا حلقه‌های تو در تو استفاده می‌کردی، اما حالا `matchAll` همه تطبیق‌ها رو به صورت یک Iterator برمی‌گردونه که دسترسی بهشون رو خیلی راحت‌تر می‌کنه.

```javascript
const regex = /t(e)(st(\d?))/g;
const str = 'test1test2';
const matches = [...str.matchAll(regex)];

console.log(matches[0]);
// Output:
// ["test1", "e", "st1", "1"]

console.log(matches[1]);
// Output:
// ["test2", "e", "st2", "2"]
```

در این مثال، `matchAll` همه‌ی تطبیق‌های عبارت منظم `regex` رو در رشته `str` پیدا می‌کنه و به صورت یک آرایه از نتایج برمی‌گردونه. این ویژگی برای کار با متن‌هایی که نیاز به پردازش دقیق دارند، مثل استخراج داده از اسناد یا تجزیه و تحلیل رشته‌ها، خیلی مفید هست.

## عملگر Nullish Coalescing

### 3. عملگر `Nullish Coalescing` چطور می‌تونه کدهای شما رو پایدارتر کنه؟
عملگر `??` که به عنوان `Nullish Coalescing` شناخته میشه، به شما این امکان رو میده که وقتی یک متغیر `null` یا `undefined` هست، به طور ایمن یک مقدار پیش‌فرض به اون اختصاص بدی. این عملگر به خصوص در مواردی که ممکنه متغیرها از منابع خارجی دریافت بشن و مقداری نداشته باشن، بسیار مفیده و می‌تونه از بروز خطاهای غیرمنتظره جلوگیری کنه.

```javascript
const foo = null ?? 'default';
const bar = 0 ?? 'default';

console.log(foo); // 'default'
console.log(bar); // 0
```

در این مثال، `foo` به خاطر اینکه `null` هست، مقدار پیش‌فرض 'default' رو می‌گیره، ولی `bar` چون مقدار `0` داره که یک مقدار معتبر هست، همون مقدار خودش رو نگه می‌داره. این عملگر به خصوص وقتی مفیده که بخوای متغیرهایی با مقادیر پیش‌فرض مطمئن داشته باشی.

## عملگر Optional Chaining

### 4. عملگر `Optional Chaining` چطور به جلوگیری از خطاها کمک می‌کنه؟
عملگر `?.` که به عنوان `Optional Chaining` معرفی شده، به شما این امکان رو میده که بدون اینکه نگران وجود یا عدم وجود ویژگی‌ها یا متدها در یک زنجیره باشید، بهشون دسترسی پیدا کنی. این عملگر از بروز خطاهای `undefined` یا `null` جلوگیری می‌کنه و به کدتون پایداری بیشتری می‌بخشه.

```javascript
const user = {
    profile: {
        name: 'John'
    }
};

const userName = user?.profile?.name;
const userAge = user?.profile?.age;

console.log(userName); // 'John'
console.log(userAge); // undefined (بدون خطا)
```

در این مثال، با استفاده از `?.` به صورت ایمن به ویژگی‌های `profile` و `name` دسترسی پیدا کردیم. اگه هر کدوم از این ویژگی‌ها وجود نداشته باشه، به جای اینکه برنامه به خطا بخوره، `undefined` برمی‌گردونه و اجرای کد بدون مشکل ادامه پیدا می‌کنه.

## عملگر Logical AND Assignment

### 5. عملگر `Logical AND Assignment` چه زمانی مفیده و چطور کار می‌کنه؟
عملگر `&&=` که در ES11 معرفی شد، به شما این امکان رو میده که یه مقدار رو فقط در صورتی به یه متغیر اختصاص بدی که مقدار فعلی اون متغیر `true` باشه. این عملگر به خصوص وقتی مفیده که بخوای به طور شرطی یه مقدار رو تغییر بدی، بدون اینکه مجبور باشی کل شرط رو بنویسی.

```javascript
let x = true;
let y = false;

x &&= 'Assigned if true';
y &&= 'Not assigned because false';

console.log(x); // 'Assigned if true'
console.log(y); // false
```

در این مثال، مقدار `x` چون `true` هست، تغییر می‌کنه، ولی مقدار `y` که `false` هست، ثابت می‌مونه و تغییری نمی‌کنه. این عملگر می‌تونه نوشتن شرط‌های پیچیده رو در کد ساده‌تر و خواناتر کنه.

## عملگر Logical OR Assignment

### 6. عملگر `Logical OR Assignment` چطور می‌تونه به ساده‌سازی شرط‌ها کمک کنه؟
عملگر `||=` به شما این امکان رو میده که یه مقدار رو به یه متغیر اختصاص بدی، ولی فقط در صورتی که مقدار فعلی اون متغیر `false`، `null`، یا `undefined` باشه. این عملگر به خصوص وقتی مفیده که بخوای یه مقدار پیش‌فرض به متغیری بدی که ممکنه هنوز مقداردهی نشده باشه.

```javascript
let a = null;
let b = 'Already set';

a ||= 'Set because null';
b ||= 'Not set because already has a value';

console.log(a); // 'Set because null'
console.log(b); // 'Already set'
```

در این مثال، `a` چون `null` هست، مقدار جدیدی می‌گیره ولی `b` که از قبل مقدار داره، همون مقدار رو حفظ می‌کنه. این عملگر به شما کمک می‌کنه که شرط‌های ساده‌تری بنویسی و از پیچیدگی‌های اضافی جلوگیری کنی.

## عملگر Nullish Coalescing Assignment

### 7. عملگر `Nullish Coalescing Assignment` چه تفاوتی با سایر عملگرهای تخصیص داره؟
عملگر `??=` به شما این امکان رو میده که یه مقدار رو به یه متغیر اختصاص بدی، ولی فقط در صورتی که مقدار فعلی اون `null` یا `undefined` باشه. این عملگر به خصوص وقتی مفیده که بخوای مطمئن بشی یه متغیر مقداردهی شده ولی نمی‌خوای مقادیر `false` یا `0` رو بازنویسی کنی.

```javascript
let c = null;
let d = 'Already defined';

c ??= 'Set because null';
d ??= 'Not set because already defined';

console.log(c); // 'Set because null'
console.log(d); // 'Already defined'
```

در این مثال، `c` چون مقدار `null` داره، با مقدار جدید جایگزین میشه ولی `d` که مقدار معتبر داره، تغییری نمی‌کنه. این عملگر به شما کمک می‌کنه که مقداردهی‌های پیش‌فرض رو به شکلی ایمن‌تر انجام بدی.

## متد Promise.allSettled

### 8. متد `Promise.allSettled` چه کاربردی داره و چطور می‌تونه به مدیریت وعده‌ها کمک کنه؟
متد `Promise.allSettled` به شما این امکان رو میده که منتظر بمونی تا همه‌ی وعده‌ها (`Promises`)، چه موفق و چه ناموفق، به پایان برسن و بعد نتیجه‌ی نهایی هر کدوم رو بررسی کنی. این متد به خصوص وقتی مفیده که بخوای همه نتایج رو دریافت کنی و فقط به موارد موفق یا ناموفق توجه نکنی.

```javascript
const promise1 = Promise.resolve('Resolved');
const promise2 = Promise.reject('Rejected');
const promise3 = new Promise

((resolve) => setTimeout(resolve, 1000, 'Delayed'));

Promise.allSettled([promise1, promise2, promise3])
    .then((results) => results.forEach((result) => console.log(result.status)));
/* Output:
resolved
rejected
fulfilled
*/
```

در این مثال، `Promise.allSettled` صبر می‌کنه تا هر سه وعده به پایان برسن، چه موفق و چه ناموفق، و بعد وضعیت نهایی هر کدوم رو لاگ می‌کنه. این متد برای زمانی مفیده که بخوای از وضعیت همه وعده‌ها مطلع بشی و به همه نتایج، چه موفق و چه ناموفق، رسیدگی کنی.

## ویژگی Dynamic Import

### 9. ویژگی `Dynamic Import` چطور می‌تونه به بهینه‌سازی بارگذاری کد کمک کنه؟
ویژگی `Dynamic Import` به شما این امکان رو میده که ماژول‌ها رو به صورت پویا و تنها زمانی که نیاز هست بارگذاری کنی. این کار باعث میشه که بار اولیه صفحه یا برنامه کاهش پیدا کنه و بخش‌های دیگه فقط زمانی بارگذاری بشن که واقعاً نیاز هستن. این ویژگی به بهینه‌سازی عملکرد و کاهش زمان بارگذاری کمک می‌کنه.

```javascript
// Dynamic Import
// فرض کن یه ماژول به اسم 'math.js' داریم که حاوی توابع مختلفی هست
async function loadMathModule() {
    const math = await import('./math.js');
    console.log(math.add(2, 3)); // استفاده از تابع add از ماژول math
}

loadMathModule();
```

در این مثال، ماژول `math.js` فقط وقتی که نیاز بهش داریم (داخل تابع `loadMathModule`) بارگذاری میشه. این کار باعث میشه که بار اولیه صفحه یا برنامه کاهش پیدا کنه و کاربر فقط ماژول‌هایی که واقعاً نیاز داره رو دانلود کنه. این ویژگی برای بهینه‌سازی عملکرد برنامه‌های وب و کاهش زمان بارگذاری صفحات خیلی مفیده.
