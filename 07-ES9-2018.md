# سوالات ES9 - 2018

## حلقه Asynchronous Iteration

### 1. استفاده از `for-await-of` تو ES9 چطوریه؟
> تو ES9 یه قابلیت جالب به اسم `for-await-of` اضافه شد که می‌تونی باهاش راحت‌تر روی داده‌هایی که به صورت غیرهمزمان میان، تکرار کنی. این حلقه درست مثل `for-of` کار می‌کنه، فقط فرقش اینه که منتظر `Promise`ها می‌مونه. این ویژگی وقتی خیلی به درد می‌خوره که مثلاً بخوای از API یا دیتابیس داده بگیری و لازمه صبر کنی تا نتیجه بیاد.
```javascript
async function* asyncGenerator() {
    yield 'Hello';
    yield 'World';
}

(async () => {
    for await (const value of asyncGenerator()) {
        console.log(value); // هر مقدار رو لاگ کن
    }
    // Output:
    // Hello
    // World
})();
```
> تو این مثال، از یه تابع غیرهمزمان برای تولید داده‌ها استفاده شده. بعدش با `for-await-of` داده‌ها رو یکی یکی می‌گیری و چاپ می‌کنی. اینطوری می‌تونی داده‌هایی که دیرتر میان رو هم مدیریت کنی.

## متد Promise.prototype.finally

### 2. متد `finally` تو ES9 چطوریه؟
> متد `finally` تو ES9 به `Promise`ها اضافه شد و اینطوری همیشه می‌تونی یه کد رو بعد از حل شدن یا رد شدن `Promise` اجرا کنی. این برای تمیزکاری و کارای نهایی خیلی مفیده. مثلاً فرض کن می‌خوای بعد از گرفتن داده‌ها، لودینگ رو مخفی کنی؛ با `finally` مطمئنی که این کار انجام میشه.
```javascript
fetch('https://api.example.com/data')
    .then(response => response.json())
    .catch(error => console.error('Error:', error))
    .finally(() => console.log('Request finished')); // این کد همیشه اجرا میشه
```
> تو این مثال، `finally` تضمین می‌کنه که بعد از اتمام درخواست، پیغام "Request finished" نمایش داده بشه، چه موفق شده باشه چه شکست خورده باشه. این کار خیلی برای بهینه‌سازی تجربه کاربری خوبه.

## ویژگی‌های Object Rest

### 3. استفاده از ویژگی‌های `Object Rest` تو ES9 چطوریه؟
> تو ES9، ویژگی‌های `Rest` به اشیاء گسترش پیدا کردن. این ویژگی بهت اجازه میده بخش‌های باقی‌مونده از یه شیء رو به صورت یه شیء جدید استخراج کنی. این قابلیت خیلی به درد می‌خوره وقتی می‌خوای یه سری ویژگی خاص رو از یه شیء جدا کنی و بقیه رو نگه داری.
```javascript
const obj = { a: 1, b: 2, c: 3 };
const { a, ...rest } = obj;

console.log(rest); // { b: 2, c: 3 }
```
> تو این مثال، ویژگی `a` از شیء اصلی جدا شده و بقیه ویژگی‌ها به عنوان یه شیء جدید به نام `rest` ذخیره شدن. اینطوری می‌تونی به راحتی بخش‌های مختلف یه شیء رو مدیریت کنی.

## ویژگی‌های جدید RegExp

### 4. چه ویژگی‌های جدیدی برای `RegExp` تو ES9 معرفی شدن؟
> تو ES9، چندین ویژگی جدید به `RegExp` اضافه شد که کار با عبارات منظم رو ساده‌تر و قدرتمندتر می‌کنن. این ویژگی‌ها شامل گروه‌های نام‌گذاری شده، Lookbehind Assertions و فلگ `s` یا همون dotAll هستن.
- **گروه‌های نام‌گذاری شده:** این قابلیت بهت اجازه میده به گروه‌های تطبیق داده شده تو یه عبارت منظم یه اسم بدی تا دسترسی بهشون راحت‌تر باشه.
- **Lookbehind Assertions:** این ویژگی بهت اجازه میده الگوهایی رو فقط در صورتی تطبیق بدی که قبل از اون‌ها یه الگوی خاص باشه.
- **فلگ `s` (dotAll):** باعث میشه که نقطه (`.`) تو عبارت منظم هر کاراکتری، حتی کاراکترهای خط جدید رو تطبیق بده.
```javascript
// Named Capture Groups
const regExp = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const match = regExp.exec('2024-08-12');
console.log(match.groups.year); // 2024

// Lookbehind Assertions
const lookbehindRegExp = /(?<=\$)\d+/;
console.log(lookbehindRegExp.exec('$100')[0]); // 100

// dotAll flag
const dotAllRegExp = /foo.bar/s;
console.log(dotAllRegExp.test('foo\nbar')); // true
```
> تو این مثال‌ها، از ویژگی‌های جدید `RegExp` مثل گروه‌های نام‌گذاری شده، Lookbehind Assertions و فلگ `s` استفاده شده تا عبارات منظم قوی‌تر و انعطاف‌پذیرتری بسازیم.

## حافظه اشتراکی جاوا اسکریپت

### 5. حافظه اشتراکی تو جاوا اسکریپت تو ES9 چطوریه؟
> تو ES9، پشتیبانی از حافظه اشتراکی و عملیات اتمی با استفاده از `SharedArrayBuffer` و `Atomics` به جاوا اسکریپت اضافه شد. این ویژگی‌ها بهت اجازه میدن که داده‌ها رو به صورت ایمن بین چندین نخ یا وب ورکر به اشتراک بذاری و عملیات‌هایی انجام بدی که هیچ وقت توسط نخ‌های دیگه قطع نمیشن.
```javascript
const buffer = new SharedArrayBuffer(1024); // ایجاد یه بافر اشتراکی
const uint8 = new Uint8Array(buffer); // ایجاد یه آرایه تایپی برای دسترسی به بافر

Atomics.add(uint8, 0, 10); // به صورت اتمی 10 رو به اولین عنصر اضافه کن
console.log(Atomics.load(uint8, 0)); // 10
```
> تو این مثال، یه `SharedArrayBuffer` با اندازه 1024 بایت ساخته شده و بعدش یه `Uint8Array` برای دسترسی به این بافر ایجاد شده. با استفاده از `Atomics.add` یه عملیات اتمی انجام میدیم که مطمئن بشیم هیچ نخ دیگه‌ای وسط این عملیات نمیاد و مقادیر رو تغییر نمیده. این ویژگی‌ها برای برنامه‌نویسی موازی و بهینه‌سازی کارایی خیلی مفیدن.
