# سوالات ES6 - 2015

## کلمه کلیدی let در جاوا اسکریپت

### 1. چرا `let` به جاوا اسکریپت اضافه شد و چه مزایایی نسبت به `var` داره؟
کلمه کلیدی `let` به جاوا اسکریپت اضافه شد تا محدودیت‌های کلمه کلیدی `var` رو برطرف کنه. وقتی از `var` برای تعریف متغیرها استفاده می‌کردیم، دامنه متغیرها به کل تابع (یا به صورت کلی، به کل اسکریپت) محدود می‌شد. این موضوع می‌تونست مشکلات زیادی ایجاد کنه، مثلاً اگه یه متغیر تو یه بلوک کد به اشتباه بازنویسی می‌شد، ممکن بود باعث بروز خطاهای پیش‌بینی‌نشده بشه. 

با `let`، متغیرها فقط درون همون بلوکی که تعریف شدن (مثل `{}`) معتبر هستن و بیرون از اون بلوک، دسترسی بهشون امکان‌پذیر نیست. این باعث میشه مدیریت متغیرها ساده‌تر بشه و از بروز مشکلات ناشی از تداخل متغیرها جلوگیری کنه.

```javascript
var x = 10;
{
  let x = 2;
  console.log(x); // 2 - اینجا مقدار x تو این بلوک 2 هست
}
console.log(x); // 10 - ولی بیرون از اون بلوک، مقدار x دوباره 10 میشه
```

در این مثال، می‌بینیم که `let` به ما اجازه میده دو متغیر با همون اسم رو در دو بخش مختلف کد داشته باشیم، بدون اینکه با هم تداخل پیدا کنن. این ویژگی به ویژه در پروژه‌های بزرگ و پیچیده، که ممکنه متغیرهای زیادی با دامنه‌های مختلف داشته باشیم، بسیار مفیده.

## کلمه کلیدی const در جاوا اسکریپت

### 2. چه زمانی باید از `const` استفاده کنیم و چه تفاوتی با `let` داره؟
کلمه کلیدی‌ `const` برای تعریف متغیرهایی استفاده میشه که نباید مقدارشون تغییر کنه. این متغیرها بعد از مقداردهی، ثابت می‌مونن و نمی‌تونی دوباره بهشون مقدار جدیدی بدی. با این حال، اگه `const` برای یه شیء یا آرایه استفاده بشه، می‌تونی محتویات اون شیء یا آرایه رو تغییر بدی، ولی نمی‌تونی خود متغیر رو به یه شیء یا آرایه دیگه اختصاص بدی.

این ویژگی باعث میشه که از تغییرات ناخواسته در متغیرهایی که باید ثابت بمونن، جلوگیری بشه. `const` به خصوص برای تعریف مقادیری مثل پارامترهای ثابت، تنظیمات و سایر مواردی که نباید تغییر کنن، خیلی کاربرد داره.

```javascript
const x = 10;
{
  const x = 2;
  console.log(x); // 2 - اینجا مقدار x تو این بلوک 2 هست
}
console.log(x); // 10 - ولی بیرون از اون بلوک، x هنوز 10 هست
```

این مثال نشون میده که با `const` می‌تونی متغیرهایی رو تعریف کنی که تو دامنه بلوکی خودشون ثابت هستن و این باعث میشه کدتون پایدارتر و از خطاهای احتمالی در امان بمونه.

## توابع پیکانی (Arrow Functions)

### 3. توابع پیکانی چه کاربردهایی دارن و چه مزایایی نسبت به توابع سنتی دارن؟
توابع پیکانی (Arrow Functions) یه روش جدید و ساده‌تر برای نوشتن توابع در جاوا اسکریپت هستن. این توابع به خاطر ساختار مختصرشون، باعث میشن کدها کوتاه‌تر و خواناتر بشن. بر خلاف توابع سنتی، توابع پیکانی نیازی به کلمات `function` و `return` ندارن و می‌تونی با حذف این کلمات، کدهای ساده‌تری بنویسی. 

یکی از ویژگی‌های مهم توابع پیکانی اینه که `this` رو از محیط بالاتر به ارث می‌برن، به این معنی که دیگه نیازی به نگه‌داری `this` تو متغیرهای موقتی نیست. با این حال، به دلیل همین ویژگی، توابع پیکانی برای استفاده به عنوان متدهای شیء مناسب نیستن.

```javascript
// JS
// تابع معمولی تو ES5
var x = function(x, y) {
  return x * y;
}

// تابع پیکانی تو ES6
const x = (x, y) => x * y;
```

این مثال نشون میده که چطور توابع پیکانی می‌تونن جایگزین توابع سنتی بشن و کدنویسی رو ساده‌تر کنن. توابع پیکانی برای مواردی مثل `callback`‌ها، توابع کوتاه و ساده، و جاهایی که نیاز به کدنویسی سریع و خوانا داریم، بسیار مناسبن.

## تخریب شیء (Object Destructuring)

### 4. تخریب شیء چطور کار می‌کنه و چرا مفیده؟
تخریب شیء (Object Destructuring) یه روش خیلی کاربردی برای برداشتن مقادیر از یه شیء و اختصاص اون‌ها به متغیرهای جداگانه هست. به جای اینکه بخوای دونه‌دونه ویژگی‌های یه شیء رو به متغیرها اختصاص بدی، می‌تونی با استفاده از تخریب، این کار رو خیلی سریع و راحت انجام بدی. 

این ویژگی به خصوص وقتی که با اشیاء پیچیده‌ای کار می‌کنی که شامل چندین ویژگی هستن، خیلی به درد می‌خوره و کدها رو کوتاه‌تر و خواناتر می‌کنه.

```javascript
const person = {
  firstName: "John",
  lastName: "Doe",
  age: 50,
  eyeColor: "blue"
};

let { firstName, age } = person;
console.log(firstName); // 'John'
console.log(age); // 50
```

تو این مثال، ویژگی‌های `firstName` و `age` از شیء `person` استخراج و به متغیرهای جداگانه اختصاص داده شدن. این روش به خصوص وقتی مفیده که بخوای فقط بعضی از ویژگی‌های یه شیء رو استخراج کنی و نیازی به بقیه‌شون نداری.

## تخریب آرایه (Array Destructuring)

### 5. تخریب آرایه چیه و چه موقع‌هایی به درد می‌خوره؟
تخریب آرایه (Array Destructuring) یه روش راحت برای استخراج مقادیر از آرایه‌ها و اختصاص اون‌ها به متغیرهاست. با این روش می‌تونی به جای اینکه به صورت دستی به هر عنصر آرایه دسترسی داشته باشی و اونا رو به متغیرها اختصاص بدی، با یه دستور ساده این کار رو انجام بدی.

این ویژگی به خصوص وقتی که با آرایه‌های بزرگ یا پیچیده‌ای کار می‌کنی که می‌خوای فقط به چند تا از عناصرشون دسترسی داشته باشی، خیلی مفیده و کدها رو مختصرتر و خواناتر می‌کنه.

```javascript
const fruits = ["Banana", "Orange", "Apple", "Mango"];

let [fruit1, fruit2] = fruits;
console.log(fruit1); // 'Banana'
console.log(fruit2); // 'Orange'
```

تو این مثال، دو عنصر اول آرایه `fruits` به متغیرهای `fruit1` و `fruit2` اختصاص داده شدن. تخریب آرایه برای مواقعی که نیاز به دسترسی سریع و ساده به چندین عنصر از یه آرایه داری، خیلی کاربردیه.

## عملگر Spread

### 6. عملگر `Spread` چیه و چرا تو جاوا اسکریپت اضافه شده؟
عملگر `...` یا همون `Spread` یکی از ویژگی‌های قدرتمند تو ES6 هست که بهت اجازه میده یه آرایه یا شیء قابل پیمایش رو به صورت تفکیک‌شده داخل یه آرایه یا تابع دیگه قرار بدی. این عملگر بهت کمک می‌کنه تا آرایه‌ها رو به هم بچسبونی، کپی کنی یا حتی عناصر یه آرایه رو به عنوان آرگومان‌های یه تابع بفرستی.

این ویژگی کدنویسی رو هم ساده‌تر و هم تمیزتر می‌کنه و باعث میشه که عملیات‌هایی مثل ترکیب، کپی‌کردن یا ارسال آرگومان‌ها توی کد به سادگی انجام بشه.

```javascript
const q1 = ["Jan", "Feb", "Mar"];
const q2 = ["Apr", "May", "Jun"];
const q3 = ["Jul", "Aug", "Sep"];
const q4 = ["Oct", "Nov", "Dec"];

const year = [...q1, ...q2, ...q3, ...q4];
console.log(year); // ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
```

تو این مثال، با استفاده از عملگر `Spread`، چهار تا آرایه به هم چسبیده شدن و یه آرایه جدید به نام `year` رو تشکیل دادن. این عملگر به خصوص برای کدنویسی‌هایی که نیاز به ترکیب داده‌ها یا ارسال آرگومان‌ها دارن، خیلی کاربردیه.

## حلقه For/of

### 7. حلقه `for/of` چیه و چه کاربردهایی داره؟
حلقه `for/of` یه روش جدید برای پیمایش مقادیر در جاوا اسکریپت هست که بهت اجازه میده به سادگی روی عناصر یه شیء قابل پیمایش (مثل آرایه‌ها، رشته‌ها، mapها و مجموعه‌ها) تکرار کنی. برخلاف `for/in` که روی کلیدها یا ایندکس‌ها تکرار می‌کنه، `for/of` به طور مستقیم روی مقادیر تکرار می‌کنه و این ویژگی باعث میشه که کدهایتون خواناتر و کم‌خطاتر بشن.

این حلقه به ویژه برای کار با داده‌هایی که قابل پیمایش هستن، مثل آرایه‌ها و رشته‌ها، خیلی مفیده.

```javascript
const cars = ["BMW", "Volvo", "Mini"];
let text = "";

for (let x of cars) {
  text += x + " ";
}
console.log(text); // 'BMW Volvo Mini '
```

تو این مثال، حلقه `for/of` روی عناصر آرایه `cars` تکرار می‌کنه و هر بار مقدار اون عنصر رو به متغیر `text` اضافه می‌کنه. این حلقه بهت اجازه میده بدون درگیری با ایندکس‌ها، به طور مستقیم با مقادیر کار کنی و این باعث میشه کدت هم ساده‌تر بشه.

## شیء Map

### 8. شیء `Map` چیه و چه کاربردهایی داره؟
شیء `Map` یه نوع داده‌ی جدید تو جاوا اسکریپت هست که بهت اجازه میده یه شیء به عنوان کلید استفاده کنی و به مقادیر مرتبط با اون دسترسی داشته باشی. برخلاف اشیاء معمولی که فقط از رشته‌ها به عنوان کلید استفاده می‌کنن، `Map` ها می‌تونن هر نوع داده‌ای رو به عنوان کلید بپذیرن. 

این ویژگی به خصوص برای مواقعی که نیاز داری داده‌ها رو با استفاده از کلیدهای غیرمعمول (مثل اشیاء یا آرایه‌ها) ذخیره کنی، خیلی مفیده و بهت امکان مدیریت دقیق‌تری از داده‌هات رو میده.

```javascript
const fruits = new Map([
  ["apples", 500],
  ["bananas", 300],
  ["oranges", 200]
]);

console.log(fruits.get("apples")); // 500
```

تو این مثال، `Map` بهت اجازه میده که داده‌ها رو به صورت جفت‌های کلید-مقدار ذخیره کنی و با استفاده از متد `get` بهشون دسترسی داشته باشی. این نوع داده برای مدیریت مجموعه‌هایی از داده‌ها که نیاز به کلیدهای غیرساده دارن، بسیار مناسب هست.

## شیء Set

### 9. شیء `Set` چه کاربردی داره و چه تفاوتی با آرایه‌ها داره؟
شیء `Set` یه نوع داده‌ی جدید تو جاوا اسکریپت هست که بهت اجازه میده یه مجموعه از مقادیر یکتا (بدون تکرار) رو ذخیره کنی. برخلاف آرایه‌ها که ممکنه مقادیر تکراری داشته باشن، `Set` فقط مقادیر یکتا رو نگه می‌داره. این ویژگی به خصوص وقتی مفیده که نیاز داری یه مجموعه‌ای از مقادیر رو بدون تکرار ذخیره کنی.

```javascript
const letters = new Set();

letters.add("a");
letters.add("b");
letters.add("c");
letters.add("a"); // این مقدار دوباره اضافه نمیشه چون قبلاً وجود داشته

console.log(letters.size); // 3
```

تو این مثال، `Set` بهت اجازه میده که مقادیر رو به ترتیب اضافه کنی و از ذخیره‌ی مقادیر تکراری جلوگیری کنی. `Set` به ویژه برای مواقعی که نیاز داری مقادیر یکتا رو مدیریت کنی، خیلی کاربردیه و کدت رو از پیچیدگی‌های مربوط به چک کردن تکرارها خلاص می‌کنه.

## کلاس‌ها در جاوا اسکریپت

### 10. کلاس‌ها تو جاوا اسکریپت چی هستن و چطور ازشون استفاده میشه؟
کلاس‌ها تو جاوا اسکریپت به عنوان قالب‌هایی برای ایجاد اشیاء مشابه عمل می‌کنن. این ویژگی بهت اجازه میده که ساختارهای پیچیده‌تری مثل اشیاء با متدها و ویژگی‌های خاص رو تعریف کنی. کلاس‌ها یه سینتکس ساده‌تر و خواناتر نسبت به توابع سازنده دارن و استفاده از اونا باعث میشه که کدهایتون سازمان‌دهی بهتری پیدا کنن.

```javascript
class Car {
  constructor(name, year) {
    this.name = name;
    this.year = year;
  }
}

const myCar1 = new Car("Ford", 2014);
const myCar2 = new Car("Audi", 2019);
```

تو این مثال، یه کلاس به نام `Car` تعریف شده که شامل دو ویژگی `name` و `year` هست. با استفاده از این کلاس، می‌تونی به راحتی اشیاء مختلفی از نوع `Car` بسازی و بهشون مقادیر متفاوت بدی. کلاس‌ها به خصوص تو برنامه‌هایی که نیاز به تعریف چندین نمونه از یه نوع شیء داری، خیلی مفید هستن و کدت رو منظم‌تر و خواناتر می‌کنن.

## وعده‌ها (Promises) در جاوا اسکریپت

### 11. وعده‌ها چیه و چطور به مدیریت کدهای غیرهمزمان کمک می‌کنن؟
وعده‌ها (`Promises`) تو جاوا اسکریپت بهت کمک می‌کنن که با کدهای غیرهمزمان مثل درخواست‌های سرور، به روشی ساده‌تر و قابل پیش‌بینی‌تر کار کنی. یه `Promise` نمایانگر یه عملیات غیرهمزمان و نتیجه‌ی نهایی اون هست. وقتی یه `Promise` رو تعریف می‌کنی، می‌تونی تعیین کنی که وقتی عملیات به نتیجه رسید (چه موفق و چه ناموفق)، چه اتفاقی بیفته.

این ویژگی بهت اجازه میده که کدهای غیرهمزمان رو به شکلی بنویسی که خوندنشون راحت‌تر باشه و مدیریت نتایجشون ساده‌تر بشه.

```javascript
const myPromise = new Promise(function(resolve, reject) {
  setTimeout(function() { resolve("I love You !!"); }, 3000);
});

myPromise.then(function(value) {
  console.log(value); // بعد از 3 ثانیه، پیام "I love You !!" نمایش داده میشه
});
```

تو این مثال، یه `Promise` تعریف شده که بعد از 3 ثانیه یه پیام رو برمی‌گردونه. با استفاده از `then`، می‌تونی تعیین کنی که وقتی `Promise` به نتیجه رسید، چه کاری انجام بشه. این ویژگی به ویژه تو مدیریت عملیات‌های غیرهمزمان که ممکنه زمان‌بر باشن، خیلی مفیده.

## نوع داده Symbol

### 12. نوع داده `Symbol` چیه و چه مواقعی استفاده میشه؟
نوع داده `Symbol` یه نوع داده‌ی جدید در جاوا اسکریپت هست که برای ایجاد شناسه‌های یکتا و غیرقابل تکرار استفاده میشه. `Symbols` به خصوص وقتی مفیده که نیاز داری از تداخل نام‌های متغیرها یا ویژگی‌ها تو کدت جلوگیری کنی، چون هر `Symbol` همیشه یکتا هست و حتی اگه دو تا `Symbol` با همون توضیح بسازی، باز هم متفاوت هستن.

این ویژگی برای جلوگیری از مشکلاتی مثل تداخل نام‌ها تو پروژه‌های بزرگ یا وقتی که چند نفر روی یه پروژه کار می‌کنن، خیلی کاربردیه.

```javascript
let id = Symbol('id');
const person = {
  firstName: "John",
  lastName: "Doe",
  age: 50,
  eyeColor: "blue"
};

person[id] = 140353;
console.log(person[id]); // 140353
```

تو این مثال، یه `Symbol` به نام `id` ساخته شده و به عنوان کلید در شیء `person` استفاده شده. این کار باعث میشه که کلید `id` با هیچ ویژگی دیگه‌ای در شیء تداخل نداشته باشه و همیشه یکتا بمونه.

## پارامترهای پیش‌فرض تو توابع

### 13. پارامترهای پیش‌فرض تو توابع چطور کار می‌کنن و چه فایده‌ای دارن؟
پارامترهای پیش‌فرض بهت اجازه میدن که برای پارامترهای توابع، مقادیر پیش‌فرض تعیین کنی. این یعنی اگه هنگام فراخوانی تابع، مقداری برای پارامتر مشخص نشده باشه، تابع از مقدار پیش‌فرض استفاده می‌کنه. این ویژگی نوشتن کد رو ساده‌تر می‌کنه و از بروز خطاهای ناشی از فراموش کردن مقداردهی پارامترها جلوگیری می‌کنه.

```javascript
function myFunction(x, y = 10) {
  return x + y;
}

console.log(myFunction(5)); // 15
```

تو این مثال، تابع `myFunction` یه پارامتر `y` با مقدار پیش‌فرض 10 داره. اگه هنگام فراخوانی تابع، مقدار `y` مشخص نشه، تابع به صورت خودکار از مقدار 10 استفاده می‌کنه. این ویژگی به ویژه تو جاهایی که تابع نیاز به پارامترهای زیادی داره، خیلی مفیده و کدنویسی رو منعطف‌تر می‌کنه.

## پارامتر Rest تو توابع

### 14. پارامتر Rest چیه و چه کاربردی داره؟
پارامتر `Rest` (`...`) یه راه ساده برای تعریف توابعی هست که تعداد نامشخصی از آرگومان‌ها رو دریافت می‌کنن. با این پارامتر می‌تونی همه آرگومان‌های اضافی رو به عنوان یه آرایه بگیری و باهاشون کار کنی. این ویژگی به خصوص وقتی که نمی‌دونی دقیقاً چند تا آرگومان قراره به تابع داده بشه، خیلی به درد می‌خوره.

```javascript
function sum(...args) {
  let sum = 0;
  for (let arg of args) sum += arg;
  return sum;
}

console.log(sum(4, 9, 16, 25, 29, 100, 66, 77)); // 326
```

تو این مثال، تابع `sum` می‌تونه هر تعداد آرگومان دریافت کنه و همه اون‌ها رو به عنوان یه آرایه پردازش می‌کنه. این ویژگی به خصوص برای توابعی که نیاز دارن با تعداد متغیری از آرگومان‌ها کار کنن، خیلی مفیده.

## متد String.includes

### 15. متد `includes` چطور بهت کمک می‌کنه که رشته‌ها رو بررسی کنی؟
متد `includes` به رشته‌ها اضافه شده تا بتونی به راحتی بررسی کنی که آیا یه زیررشته خاص تو یه رشته بزرگ‌تر وجود داره یا نه. این متد یه مقدار بولین (`true` یا `false`) برمی‌گردونه و برای جستجوی سریع توی رشته‌ها خیلی مفیده. 

این متد به خصوص وقتی که نیاز داری بررسی کنی آیا یه کلمه یا عبارت خاص تو یه متن بزرگ‌تر وجود داره یا نه، خیلی به کارت میاد.

```javascript
let text = "Hello world, welcome to the universe.";
console.log(text.includes("world")); // true
```

تو این مثال، `includes` بررسی می‌کنه که آیا کلمه `world` تو رشته `text` وجود داره یا نه و بر اساس نتیجه `true` یا `false` برمی‌گردونه. این متد بهت کمک می‌کنه که با کدنویسی ساده و خوانا، به راحتی محتوای رشته‌ها رو بررسی کنی.

## متد String.startsWith

### 16. چطور می‌تونی بررسی کنی که یه رشته با یه کلمه خاص شروع میشه؟
متد `startsWith` یه روش ساده برای بررسی اینه که آیا یه رشته با یه زیررشته مشخص شروع میشه یا نه. اگه رشته با اون زیررشته شروع بشه، `true` برمی‌گردونه، وگرنه `false` برمی‌گردونه. این متد برای مواقعی که نیاز داری محتوای یه رشته رو بررسی کنی، خیلی کاربردیه.

```javascript
let text = "Hello world, welcome to the universe.";
console.log(text.startsWith("Hello")); // true
```

تو این مثال، `startsWith` بررسی می‌کنه که آیا رشته `text` با `Hello` شروع میشه یا نه. این ویژگی به خصوص تو جاهایی که نیاز داری بررسی کنی که یه رشته با یه کلمه یا عبارت خاص شروع میشه، خیلی به کارت میاد.

## متد String.endsWith

### 17. چطور می‌تونی بررسی کنی که یه رشته با یه کلمه خاص تموم میشه؟
متد `endsWith` یه راه ساده برای بررسی اینه که آیا یه رشته با یه زیررشته مشخص تموم میشه یا نه. اگه رشته با اون زیررشته پایان پیدا کنه، `true` برمی‌گردونه، وگرنه `false` برمی‌گردونه. این متد برای بررسی سریع پایان رشته‌ها خیلی کاربردیه.

```javascript
let text = "John Doe";
console.log(text.endsWith("Doe")); // true
```

تو این مثال، `endsWith` بررسی می‌کنه که آیا رشته `text` با `Doe` تموم میشه یا نه. این متد به خصوص تو جاهایی که نیاز داری مطمئن بشی یه رشته به یه شکل خاصی پایان می‌پذیره، خیلی مفیده.

## متد Array.entries

### 18. متد `entries` چیه و چطور می‌تونی ازش برای پیمایش آرایه‌ها استفاده کنی؟
متد `entries` یه روش جدید برای پیمایش آرایه‌ها در جاوا اسکریپت هست که بهت اجازه میده روی جفت‌های کلید-مقدار (یعنی ایندکس و مقدار) تکرار کنی. این متد یه شیء قابل پیمایش برمی‌گردونه که می‌تونی تو یه حلقه `for/of` ازش استفاده کنی تا به هر عنصر آرایه و ایندکس مربوط بهش دسترسی داشته باشی.

```javascript
const fruits = ["Banana", "Orange", "Apple", "Mango"];
const f = fruits.entries();

for (let x of f) {
  console.log(x);
}
/* Output:
[0, "Banana"]
[1, "Orange"]
[2, "Apple"]
[3, "Mango"]
*/
```

تو این مثال، `entries` یه شیء قابل پیمایش از آرایه `fruits` برمی‌گردونه که شامل جفت‌های ایندکس-مقدار هست. این ویژگی بهت اجازه میده که تو یه حلقه به هر دو مقدار و ایندکس به صورت همزمان دسترسی داشته باشی.

## متد Array.from

### 19. متد `Array.from` چیه و چطور بهت کمک می‌کنه که اشیاء مختلف رو به آرایه تبدیل کنی؟
متد `Array.from` یه ویژگی قدرتمند تو ES6 هست که بهت اجازه میده هر شیء شبیه به آرایه (مثل `NodeList` یا رشته‌ها) یا هر شیء قابل پیمایش (iterable) رو به یه آرایه واقعی تبدیل کنی. این ویژگی خیلی مفیده وقتی که می‌خوای با اشیائی کار کنی که به شکل آرایه نیستن ولی می‌خوای از قابلیت‌های آرایه‌ها براشون استفاده کنی.

```javascript
const arr = Array.from("ABCDEFG");
console.log(arr); // ['A', 'B', 'C', 'D', 'E', 'F', 'G']
```

تو این مثال، `Array.from` رشته `ABCDEFG` رو به یه آرایه از حروف تبدیل کرده. این ویژگی به خصوص برای مواقعی که نیاز داری اشیاء رو به آرایه تبدیل کنی تا بتونی از متدهای آرایه‌ای استفاده کنی، خیلی کاربردیه.

## متد Array.keys

### 20. چطور می‌تونی با `keys` ایندکس‌های یه آرایه رو بدست بیاری؟
متد `keys` یه روش جدید برای بدست آوردن ایندکس‌های یه آرایه در جاوا اسکریپت هست. این متد یه شیء قابل پیمایش برمی‌گردونه که شامل کلیدهای (ایندکس‌های) آرایه هست. با استفاده از این متد می‌تونی به راحتی روی ایندکس‌های یه آرایه تکرار کنی و بهشون دسترسی داشته باشی.

```javascript
const fruits = ["Banana", "Orange", "Apple", "Mango"];
const keys = fruits.keys();

for (let key of keys) {
  console.log(key);
}
/* Output:
0
1
2
3
*/
```

تو این مثال، `keys` ایندکس‌های آرایه `fruits` رو برمی‌گردونه و حلقه `for/of` روی این ایندکس‌ها تکرار می‌کنه. این متد بهت کمک می‌کنه که بدون نیاز به استفاده از حلقه‌های پیچیده‌تر، به راحتی به ایندکس‌های آرایه دسترسی پیدا کنی.

## متد Array.find

### 21. چطور می‌تونی با `find` اولین عنصر مطابق شرط خاص رو از یه آرایه پیدا کنی؟
متد `find` یه روش قدرتمند تو ES6 هست که بهت اجازه میده اولین عنصری از یه آرایه که یه شرط خاص رو برآورده می‌کنه، پیدا کنی و برگردونی. این متد یه تابع به عنوان آرگومان می‌پذیره که برای هر عنصر آرایه اجرا میشه و اولین عنصری که شرط رو برآورده می‌کنه، برمی‌گردونه.

```javascript
const numbers = [4, 9, 16, 25, 29];
let first = numbers.find(function(value) {
  return value > 18;
});
console.log(first); // 25
```

تو این مثال، `find` اولین عددی از آرایه `numbers` که بزرگتر از 18 هست رو پیدا و برمی‌گردونه. این متد به ویژه برای جستجوی سریع توی آرایه‌ها و پیدا کردن اولین عنصر مطابق با شرطی خاص، خیلی مفیده.

## متد Array.findIndex

### 22. چطور می‌تونی با `findIndex` ایندکس اولین عنصر مطابق شرط خاص رو پیدا کنی؟
متد `findIndex` مشابه `find` عمل می‌کنه، با این تفاوت که به جای مقدار، ایندکس اولین عنصری که یه شرط خاص رو برآورده می‌کنه، برمی‌گردونه. این متد وقتی مفیده که نیاز داری بدونی اولین عنصری که یه شرط خاص رو داره، تو کدوم ایندکس قرار گرفته.

```javascript
const numbers = [4, 9, 16, 25, 29];
let firstIndex = numbers.findIndex(function(value) {
  return value > 18;
});
console.log(firstIndex); // 3
```

تو این مثال، `findIndex` ایندکس اولین عددی از آرایه `numbers` که بزرگتر از 18 هست رو پیدا و برمی‌گردونه. این متد به خصوص برای مواقعی که نیاز داری بدونی یه عنصر خاص تو چه موقعیتی قرار داره، خیلی مفیده.

## متدهای جدید ریاضی

### 23. تو ES6 چه متدهای جدیدی به شیء Math اضافه شدن و چه کاربردهایی دارن؟
تو ES6 چندین متد جدید به شیء Math اضافه شدن که برای انجام محاسبات خاصی استفاده می‌شن. این متدها شامل `Math.trunc`، `Math.sign`، `Math.cbrt`، `Math.log2` و `Math.log10` هستن. هر کدوم از این متدها برای انجام عملیات ریاضی خاصی طراحی شدن و بهت کمک می‌کنن که به سادگی محاسبات پیچیده‌تری رو انجام بدی.

- `Math.trunc(x)` بخش صحیح عدد `x` رو برمی‌گردونه و قسمت اعشاری رو حذف می‌کنه.
- `Math.sign(x)` نشون میده که عدد `x` منفی، مثبت یا صفره.
- `Math.cbrt(x)` ریشه سوم عدد `x` رو محاسبه می‌کنه.
- `Math.log2(x)` لگاریتم عدد `x` در پایه 2 رو برمی‌گردونه.
- `Math.log10(x)` لگاریتم عدد `x` در پایه 10 رو محاسبه می‌کنه.

```javascript
console.log(Math.trunc(4.9)); // 4
console.log(Math.sign(-4)); // -1
console.log(Math.cbrt(8)); // 2
console.log(Math.log2(8)); // 3
console.log(Math.log10(100)); // 2
```

تو این مثال‌ها، از متدهای مختلف `Math` برای انجام محاسبات ریاضی استفاده شده. این متدها به خصوص برای مواقعی که نیاز داری محاسبات خاصی رو انجام بدی، خیلی کاربردیه و کد رو ساده‌تر می‌کنه.

## ویژگی‌های جدید Number

### 24. چه ویژگی‌های جدیدی به شیء Number اضافه شده و چطور می‌تونی ازشون استفاده کنی؟
تو ES6، ویژگی‌های جدیدی به شیء Number اضافه شدن که بهت کمک می‌کنن تا با دقت بیشتری با اعداد کار کنی. این ویژگی‌ها شامل `Number.EPSILON`، `Number.MIN_SAFE_INTEGER`، `Number.MAX_SAFE_INTEGER`، `Number.isInteger` و `Number.isSafeInteger` هستن.

- `Number.EPSILON` کوچکترین فاصله بین دو عدد اعشاری در جاوا اسکریپت رو برمی‌گردونه.
- `Number.MIN_SAFE_INTEGER` کوچکترین عدد صحیحی که می‌تونه به صورت ایمن نمایش داده بشه رو مشخص می‌کنه.
- `Number.MAX_SAFE_INTEGER` بزرگترین عدد صحیحی که می‌تونه به صورت ایمن نمایش داده بشه رو مشخص می‌کنه.
- `Number.isInteger(x)` بررسی می‌کنه که آیا `x` یک عدد صحیح هست یا نه.
- `Number.isSafeInteger(x)` بررسی می‌کنه که آیا `x` یک عدد صحیح ایمن هست یا نه.

```javascript
console.log(Number.EPSILON); // 2.220446049250313e-16
console.log(Number.MIN_SAFE_INTEGER); // -9007199254740991
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
console.log(Number.isInteger(10)); // true
console.log(Number.isSafeInteger(12345678901234567890)); // false
```

این ویژگی‌ها به خصوص برای کار با اعداد و جلوگیری از خطاهای محاسباتی در جاوا اسکریپت خیلی مفید هستن.

## متدهای جدید Global

### 25. چه متدهای جدیدی تو ES6 به شیء Global اضافه شدن و چه کاربردهایی دارن؟
تو ES6 دو متد جدید به شیء Global اضافه شدن که شامل `isFinite` و `isNaN` هستن. این متدها بهت کمک می‌کنن که به راحتی بررسی کنی آیا یه مقدار عددی معتبر هست یا نه.

- `isFinite(x)` بررسی می‌کنه که آیا `x` یه عدد متناهی هست یا نه (یعنی `Infinity` یا `NaN` نیست).
- `isNaN(x)` بررسی می‌کنه که آیا `x` یه مقدار `NaN` (Not a Number) هست یا نه.

```javascript
console.log(isFinite(10/0)); // false
console.log(isFinite(10/1)); // true
console.log(isNaN("Hello")); // true
```

این متدها بهت کمک می‌کنن که به راحتی با اعداد و مقادیر خاص در جاوا اسکریپت کار کنی و از بروز خطاهای محاسباتی جلوگیری کنی.

## ماژول‌ها در جاوا اسکریپت

### 26. ماژول‌ها تو جاوا اسکریپت چطور کار می‌کنن و چه فایده‌ای دارن؟
ماژول‌ها یه ویژگی مهم تو ES6 هستن که بهت اجازه میدن کد رو به بخش‌های کوچکتر و جداگانه تقسیم کنی و این بخش‌ها رو به صورت ماژول‌های مجزا مدیریت کنی. این ویژگی باعث میشه که بتونی کدهای تکراری رو از بین ببری و مدیریت بهتری روی پروژه‌هات داشته باشی.

تو جاوا اسکریپت، ماژول‌ها به دو صورت می‌تونن import بشن:

عمل **import کردن از export نام‌گذاری شده**: این نوع import بهت اجازه میده که مقادیر خاصی رو از یه ماژول import کنی.
   ```javascript
   import { name, age } from "./person.js";
   ```

عمل **import کردن از export پیش‌فرض**: این نوع import بهت اجازه میده که یه مقدار پیش‌فرض رو از یه ماژول import کنی.
   ```javascript
   import message from "./message.js";
   ```

ماژول‌ها بهت کمک می‌کنن که کدت رو تمیزتر و سازمان‌دهی شده‌تر بنویسی و از تکرار کدها جلوگیری کنی. این ویژگی به خصوص برای پروژه‌های بزرگ خیلی مفیده و باعث میشه که نگهداری و توسعه کدهایتون راحت‌تر بشه.
