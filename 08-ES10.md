# سوالات ES10

## متدهای Array.prototype.flat و Array.prototype.flatMap

### 1. متدهای `flat` و `flatMap` تو ES10 چطوریه؟
> تو ES10، متدهای `flat` و `flatMap` به آرایه‌ها اضافه شدن تا بتونی به راحتی آرایه‌های تو در تو رو تخت کنی یا عملیات خاصی رو روی هر عنصر انجام بدی و بعدش نتیجه رو تخت کنی. این متدها باعث میشن که کدت تو کار با آرایه‌های چندبعدی ساده‌تر بشه.
```javascript
const arr = [1, [2, [3, [4]]]];
console.log(arr.flat(2)); // [1, 2, 3, [4]]

const arr2 = [1, 2, 3];
console.log(arr2.flatMap(x => [x, x * 2])); // [1, 2, 2, 4, 3, 6]
```
> تو این مثال، `flat` یه آرایه دو سطح تو در تو رو به یه سطح تبدیل می‌کنه، در حالی که `flatMap` اول هر عنصر رو به یه آرایه جدید ایجاد می‌کنه و بعدش نتیجه رو تخت می‌کنه.

## متد Object.fromEntries

### 2. متد `Object.fromEntries` تو ES10 چطوریه؟
> متد `Object.fromEntries` تو ES10 معرفی شد و بهت اجازه میده که یه آرایه از زوج‌های کلید-مقدار رو به یه شیء تبدیل کنی. این متد مکمل متد `Object.entries` هست که یه شیء رو به آرایه‌ای از زوج‌های کلید-مقدار تبدیل می‌کنه. این دو متد با هم ابزارهای قدرتمندی برای تبدیل داده‌ها بین قالب‌های مختلف ارائه میدن.
```javascript
const entries = [['a', 1], ['b', 2], ['c', 3]];
const obj = Object.fromEntries(entries);
console.log(obj); // { a: 1, b: 2, c: 3 }
```
> تو این مثال، یه آرایه از زوج‌های کلید-مقدار با استفاده از `Object.fromEntries` به یه شیء تبدیل میشه. این متد برای تبدیل داده‌هایی که به صورت آرایه‌های زوج‌های کلید-مقدار ذخیره شدن به اشیاء، خیلی مفیده.

## متدهای String.prototype.trimStart و String.prototype.trimEnd

### 3. متدهای `trimStart` و `trimEnd` تو ES10 چطوریه؟
> تو ES10، متدهای `trimStart` و `trimEnd` به رشته‌ها اضافه شدن تا بتونی به راحتی فاصله‌های خالی از ابتدا یا انتهای یه رشته رو حذف کنی. این متدها نسخه‌های خاص‌تری از متد `trim` هستن که هر دو طرف رشته رو برش می‌داد. حالا می‌تونی برش فضای خالی رو به صورت دقیق‌تر کنترل کنی.
```javascript
const str = '   Hello World!   ';
console.log(str.trimStart()); // 'Hello World!   '
console.log(str.trimEnd()); // '   Hello World!'
```
> تو این مثال، متد `trimStart` فاصله‌های خالی اول و `trimEnd` فاصله‌های خالی آخر رشته رو حذف می‌کنن. این قابلیت بهت اجازه میده تا فاصله‌های خالی غیرضروری رو به صورت هدفمند از رشته‌ها حذف کنی.

## ویژگی Optional Catch Binding

### 4. ویژگی `Optional Catch Binding` تو ES10 چطوریه؟
> تو ES10، می‌تونی تو بلاک‌های `catch` از پارامتر خطا صرف‌نظر کنی اگه نیازی بهش نداری. این کار کد رو تمیزتر و خواناتر می‌کنه، مخصوصاً وقتی که نمی‌خوای هیچ کاری با خطای دریافت شده انجام بدی.
```javascript
try {
    // some code
} catch {
    console.log('An error occurred.');
}
```
> تو این مثال، تو بلاک `catch` پارامتر خطا حذف شده چون بهش نیازی نداریم. اینطوری کد ساده‌تر و مرتب‌تر میشه.

## متد Function.prototype.toString

### 5. متد `Function.prototype.toString` تو ES10 چطوریه؟
> تو ES10، متد `Function.prototype.toString` بازبینی شده تا متن دقیق کد منبع تابع رو برگردونه. این متن شامل همه چیز میشه، از جمله کامنت‌ها و فاصله‌های خالی.
```javascript
function example() {
    // این یک کامنت است
    return "Hello, world!";
}

console.log(example.toString());
/* Output:
function example() {
    // این یک کامنت است
    return "Hello, world!";
}
*/
```
> تو این مثال، متد `toString` تابع `example` رو به همون شکلی که نوشته شده برمی‌گردونه، شامل کامنت‌ها و تمام فاصله‌های خالی. این ویژگی برای دیباگ کردن و تحلیل کد خیلی مفیده.

## ویژگی Symbol.prototype.description

### 6. ویژگی `description` برای `Symbol` تو ES10 چطوریه؟
> تو ES10، ویژگی `description` برای Symbolها معرفی شد. این ویژگی بهت اجازه میده که توضیحی که زمان ساخت Symbol تنظیم کردی رو دریافت کنی. قبلاً برای دسترسی به توضیحات Symbolها باید از روش‌های پیچیده‌تری استفاده می‌کردی، ولی حالا با استفاده از `description` به راحتی می‌تونی به این اطلاعات دسترسی داشته باشی.
```javascript
const sym = Symbol('example');
console.log(sym.description); // 'example'
```
> تو این مثال، یه Symbol با توضیح 'example' ساخته شده و بعدش این توضیح با استفاده از ویژگی `description` دریافت میشه. این ویژگی به خوندن و نگهداری کد کمک می‌کنه، به خصوص وقتی از Symbolها به عنوان کلیدهای اشیاء استفاده می‌کنی.

## ویژگی Well-formed JSON.stringify

### 7. ویژگی Well-formed `JSON.stringify` تو ES10 چطوریه؟
> تو ES10، `JSON.stringify` بهبود پیدا کرده تا همیشه رشته‌های Unicode صحیح تولید کنه. قبلاً ممکن بود `JSON.stringify` تو مواجهه با بعضی از کاراکترهای خاص Unicode، رشته‌هایی ناقص تولید کنه که به درستی پارس نمیشدن. این بهبود اطمینان میده که رشته‌های تولید شده توسط `JSON.stringify` همیشه قابل اعتماد و به درستی ساخته شده باشن.
```javascript
const str = '\uD800';
console.log(JSON.stringify(str)); // '"\\ud800"' به جای رشته معیوب
```
> تو این مثال، `JSON.stringify` یه رشته Unicode معیوب رو به درستی تبدیل کرده و در نتیجه، یه رشته قابل اعتماد و صحیح تولید می‌کنه. این ویژگی برای کار با داده‌های متنی پیچیده و بین‌المللی خیلی مفیده.

## متد Stable Array.prototype.sort

### 8. ویژگی Stable `Array.prototype.sort` تو ES10 چطوریه؟
> تو ES10، متد `sort` به گونه‌ای بهبود پیدا کرده که همیشه پایدار (stable) باشه. این یعنی وقتی دو عنصر از آرایه با کلیدهای مشابه مقایسه میشن، ترتیب اصلیشون حفظ میشه و تغییر نمی‌کنه.
```javascript
const arr = [{ name: 'John', age: 25 }, { name: 'Jane', age: 22 }, { name: 'Jack', age: 25 }];
arr.sort((a, b) => a.age - b.age);
console.log(arr);
/* Output:
[
  { name: 'Jane', age: 22 },
  { name: 'John', age: 25 },
  { name: 'Jack', age: 25 }
]
*/
```
> تو این مثال، چون متد `sort` تو ES10 پایدار شده، ترتیب اصلی عناصر با سن مشابه (مثل John و Jack) حفظ شده. این ویژگی به خصوص برای مرتب‌سازی داده‌های پیچیده که ترتیب اصلی اهمیت داره مفیده.

## ویژگی JSON Superset

### 9. ویژگی JSON Superset تو ES10 چیه؟
> تو ES10، JSON به یه سوپرست واقعی از ECMAScript تبدیل شد، به این معنا که حالا می‌تونی تو رشته‌های JSON از کاراکترهای جداکننده خط استفاده کنی بدون اینکه نیاز به تبدیل اون‌ها باشه. این کار JSON رو بیشتر با استانداردهای ECMAScript همخوان می‌کنه.
```javascript
const str = 'Hello\u2028World';
console.log(JSON.parse(`"${str}"`)); // 'Hello World'
```
> تو این مثال، کاراکتر جداکننده خط (`\u2028`) تو JSON بدون هیچ مشکلی پذیرفته میشه و به درستی پارس میشه. این ویژگی برای کار با داده‌های متنی که از منابع مختلف میان، خیلی مفیده.

## ویژگی globalThis

### ویژگی globalThis تو ES10 چطوریه؟
> تو ES10، ویژگی جدید `globalThis` معرفی شد که یه راه استاندارد برای دسترسی به شیء سراسری تو محیط‌های مختلف فراهم می‌کنه. این ویژگی بهت اجازه میده که بدون در نظر گرفتن نوع محیط (مرورگر، Node.js، یا هر محیط دیگه‌ای) به شیء سراسری دسترسی داشته باشی.

```javascript
globalThis.myGlobalVariable = 'Hello, global world!'; // تعریف متغیر سراسری با استفاده از globalThis

if (typeof window !== 'undefined') { // دسترسی به متغیر سراسری در محیط‌های مختلف
    console.log('Running in a browser environment');
    console.log(window.myGlobalVariable); // 'Hello, global world!'
} else if (typeof global !== 'undefined') {
    console.log('Running in a Node.js environment');
    console.log(global.myGlobalVariable); // 'Hello, global world!'
} else if (typeof globalThis !== 'undefined') {
    console.log('Running in another environment');
    console.log(globalThis.myGlobalVariable); // 'Hello, global world!'
}

function showGlobalVariable() { // استفاده از globalThis در تابع سراسری
    console.log(globalThis.myGlobalVariable); // 'Hello, global world!'
}

showGlobalVariable();
```

> تو این مثال، متغیری به نام `myGlobalVariable` با استفاده از `globalThis` تعریف شده که به عنوان متغیر سراسری در دسترسه. بعدش، بسته به محیطی که کد توش اجرا میشه (مثلاً مرورگر، Node.js یا محیط‌های دیگه)، این متغیر به درستی از شیء سراسری مربوطه گرفته میشه.

> ویژگی `globalThis` تضمین می‌کنه که بدون توجه به محیط اجرای کد، همیشه به شیء سراسری دسترسی داشته باشی. این ویژگی برای نوشتن کدهای سازگار با محیط‌های مختلف (مثل مرورگرها و Node.js) خیلی مفیده و باعث میشه کد کمتر وابسته به محیط خاصی باشه.
