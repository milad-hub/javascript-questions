# سوالات ES9

## حلقه Asynchronous Iteration

### 1. استفاده از `for-await-of` تو ES9 چطوریه؟
> تو ES9 یه قابلیت جالب به اسم `for-await-of` اضافه شده که می‌تونی باهاش راحت‌تر روی داده‌هایی که به صورت غیرهمزمان میان، تکرار کنی. این حلقه درست مثل `for-of` کار می‌کنه، فقط فرقش اینه که منتظر `Promise`ها می‌مونه. این ویژگی وقتی خیلی به درد می‌خوره که مثلاً بخوای از API یا دیتابیس داده بگیری و لازمه صبر کنی تا نتیجه بیاد.
```javascript
async function* asyncGenerator() {
    yield 'Hello';
    yield 'World';
}

(async () => {
    for await (const value of asyncGenerator()) {
        console.log(value); // هر مقدار رو لاگ کن
    }
    // Output:
    // Hello
    // World
})();
```
> اینجا از یه تابع غیرهمزمان برای تولید داده‌ها استفاده شده. بعدش با `for-await-of` داده‌ها رو یکی یکی می‌گیری و چاپ می‌کنی. اینطوری می‌تونی داده‌هایی که دیرتر میان رو هم مدیریت کنی.

## متد Promise.prototype.finally

### 2. متد `finally` تو ES9 چطوریه؟
> متد `finally` تو ES9 به `Promise`ها اضافه شده و اینطوری همیشه می‌تونی یه کد رو بعد از حل شدن یا رد شدن `Promise` اجرا کنی. این برای تمیزکاری و کارای نهایی خیلی مفیده. مثلاً فرض کن می‌خوای بعد از گرفتن داده‌ها، لودینگ رو مخفی کنی، با `finally` مطمئنی که این کار انجام میشه.
```javascript
fetch('https://api.example.com/data')
    .then(response => response.json())
    .catch(error => console.error('Error:', error))
    .finally(() => console.log('Request finished')); // این کد همیشه اجرا میشه
```
> تو این مثال، `finally` تضمین می‌کنه که بعد از اتمام درخواست، پیغام "Request finished" نمایش داده بشه، چه موفق شده باشه چه شکست خورده باشه. این کار خیلی برای بهینه‌سازی تجربه کاربری خوبه.

## ویژگی‌های Rest/Spread

### 3. استفاده از ویژگی‌های `Rest/Spread` برای اشیاء تو ES9 چطوریه؟
> تو ES9، ویژگی‌های `Rest` و `Spread` که قبلاً تو آرایه‌ها استفاده می‌شدن، حالا تو اشیاء هم کاربرد دارن. این ویژگی‌ها خیلی وقتا کارو راحت‌تر می‌کنن، مثلاً وقتی می‌خوای چند تا شیء رو با هم ترکیب کنی یا یه بخش از یه شیء رو جدا کنی.
```javascript
const obj = { a: 1, b: 2, c: 3 };
const { a, ...rest } = obj; // استفاده از Rest برای اشیاء
console.log(rest); // { b: 2, c: 3 }

const newObj = { ...rest, d: 4 }; // استفاده از Spread برای اشیاء
console.log(newObj); // { b: 2, c: 3, d: 4 }
```
> تو این مثال، اول `a` رو از شیء جدا کردیم و بقیه‌ی ویژگی‌ها رو گذاشتیم تو یه شیء جدید به اسم `rest`. بعدش `rest` رو با یه ویژگی جدید ترکیب کردیم و یه شیء جدید ساختیم. اینطوری می‌تونی بدون دردسر اشیاء رو دستکاری کنی.

## بهبودهای RegExp

### 4. چه بهبودهایی برای `RegExp` تو ES9 معرفی شدن؟
> تو ES9 چند تا تغییر جالب تو عبارات منظم (RegExp) ایجاد شده. این تغییرات شامل گروه‌های نامگذاری شده، Lookbehind Assertions و فلگ `s` یا همون dotAll میشن. با این قابلیت‌ها می‌تونی خیلی بهتر و دقیق‌تر با رشته‌ها کار کنی.
- **گروه‌های نامگذاری شده:** می‌تونی برای گروه‌هایی که تطبیق داده میشن اسم بذاری، اینطوری دسترسی بهشون خیلی راحت‌تر میشه.
- **Lookbehind Assertions:** اینم بهت اجازه میده که فقط وقتی یه الگو رو تطبیق بدی که قبلش یه چیز خاص باشه.
- **فلگ `s` (dotAll):** باعث میشه نقطه (`.`) تو عبارت منظم هر چیزی رو بگیره، حتی خط جدید.
```javascript
// Named Capture Groups
const regExp = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const match = regExp.exec('2024-08-12');
console.log(match.groups.year); // 2024

// Lookbehind Assertions
const lookbehindRegExp = /(?<=\$)\d+/;
console.log(lookbehindRegExp.exec('$100')[0]); // 100

// dotAll flag
const dotAllRegExp = /foo.bar/s;
console.log(dotAllRegExp.test('foo\nbar')); // true
```
> این مثال‌ها نشون میدن که چطور می‌تونی از این ویژگی‌ها استفاده کنی. گروه‌های نامگذاری شده دسترسی به year، month و day رو آسون‌تر می‌کنن. Lookbehind فقط وقتی عدد رو تطبیق میده که قبلش `$` باشه و فلگ `s` هم باعث میشه که نقطه هر چیزی، حتی خط جدید رو هم بگیره.

## بازبینی Template Literals

### 5. بازبینی Template Literals تو ES9 چطوریه؟
> تو ES9، قابلیت‌های Template Literals بهبود پیدا کردن تا انعطاف‌پذیری و قدرت بیشتری داشته باشن. یکی از این قابلیت‌های جدید `tagged template literals` هست که بهت اجازه میده تگ‌های سفارشی برای قالب‌های متنی بسازی و نحوه پردازش اون‌ها رو کنترل کنی. این قابلیت به خصوص برای پردازش رشته‌های چندخطی، تبدیل مقادیر، و اعمال توابع روی مقادیر داخل رشته‌ها خیلی به درد می‌خوره.
```javascript
function tag(strings, ...values) {
    return strings[0] + values.map(value => value.toUpperCase()).join('');
}

const name = 'world';
console.log(tag`Hello, ${name}!`); // 'Hello, WORLD!'
```
> تو این مثال، از یه تابع تگ (`tag`) استفاده شده که همه مقادیر داخلی (`values`) رو به حروف بزرگ تبدیل می‌کنه. این قابلیت بهت اجازه میده کنترل بیشتری روی نمایش رشته‌های قالب‌بندی شده داشته باشی.

## تبدیل ویژگی‌های یونیکد در RegExp

### 6. ویژگی‌های تبدیل یونیکد در `RegExp` تو ES9 چطوریه؟
> تو ES9، پشتیبانی از تبدیل ویژگی‌های یونیکد به عبارات منظم اضافه شد. این ویژگی بهت اجازه میده که به راحتی کاراکترهایی با ویژگی‌های خاص تو مجموعه یونیکد رو تطبیق بدی. این کار با استفاده از الگوهای `\p{...}` انجام میشه که می‌تونن بر اساس اسکریپت، دسته، یا ویژگی‌های دیگه یونیکد تعریف بشن.
```javascript
const regex = /\p{Script=Greek}/u;
console.log(regex.test('α')); // true
console.log(regex.test('a')); // false
```
> تو این مثال، عبارت منظم تعریف شده کاراکترهایی که تو اسکریپت یونانی (`Greek`) قرار دارن رو تطبیق میده. این ویژگی برای کار با متن‌های چندزبانه و تحلیل رشته‌های پیچیده خیلی مفیده.

## ویژگی JSON Superset

### 7. ویژگی JSON Superset تو ES9 چیه؟
> تو ES9، امکان استفاده از کاراکترهای `\u2028` و `\u2029` تو رشته‌های JSON اضافه شد. این کاراکترها که به ترتیب برای جداکننده خط (Line Separator) و جداکننده پاراگراف (Paragraph Separator) استفاده میشن، قبلاً تو JSON معتبر نبودن و باعث ایجاد خطا تو پارس می‌شدن. ES9 با اضافه کردن این ویژگی، JSON رو به یه سوپرست کامل از اکما اسکریپت تبدیل کرد.
```javascript
const str = 'Hello\u2028World';
console.log(JSON.parse(`"${str}"`)); // 'Hello World'
```
> تو این مثال، رشته‌ای که شامل کاراکتر جداکننده خط (`\u2028`) هست، با موفقیت پارس میشه. این ویژگی به خصوص برای کار با داده‌های متنی که از منابع مختلف با قالب‌بندی‌های متفاوت میان، خیلی مفیده.

## ویژگی Symbol.prototype.description

### 8. ویژگی `description` برای `Symbol` تو ES9 چطوریه؟
> تو ES9، ویژگی `description` برای Symbolها معرفی شد. این ویژگی بهت اجازه میده که توضیحی که زمان ساخت Symbol تنظیم کردی رو دریافت کنی. قبلاً برای دسترسی به توضیحات Symbolها باید از روش‌های پیچیده‌تری استفاده می‌کردی، ولی حالا با استفاده از `description` به راحتی می‌تونی به این اطلاعات دسترسی داشته باشی.
```javascript
const sym = Symbol('example');
console.log(sym.description); // 'example'
```
> تو این مثال، یه Symbol با توضیح 'example' ساخته شده و بعدش این توضیح با استفاده از ویژگی `description` دریافت میشه. این ویژگی به خوندن و نگهداری کد کمک می‌کنه، به خصوص وقتی از Symbolها به عنوان کلیدهای اشیاء استفاده می‌کنی.

## بازبینی متد Function.prototype.toString

### 9. بازبینی متد `Function.prototype.toString` تو ES9 چطوریه؟
> تو ES9، متد `Function.prototype.toString` بازبینی شد تا متن دقیق کد منبع تابع رو، شامل همه فاصله‌های خالی و کامنت‌ها، برگردونه. این بازبینی بهت کمک می‌کنه تا بتونی کد منبع توابع رو دقیقاً همون‌طوری که نوشته شدن، دوباره بازیابی کنی. این ویژگی برای دیباگ کردن و تحلیل کد خیلی مفیده.
```javascript
function example() {
    // این یک کامنت است
    return "Hello, world!";
}

console.log(example.toString());
/* Output:
function example() {
    // این یک کامنت است
    return "Hello, world!";
}
*/
```
> تو این مثال، متد `toString` تابع `example` رو به صورت کامل، شامل کامنت داخلش، برمی‌گردونه. این کار باعث میشه اطلاعات بیشتری از کد تابع برای تحلیل در دسترس باشه.

## متد Object.fromEntries

### 10. متد `Object.fromEntries` تو ES9 چطوریه؟
> متد `Object.fromEntries` تو ES9 معرفی شد و بهت اجازه میده که یه آرایه از زوج‌های کلید-مقدار رو به یه شیء تبدیل کنی. این متد مکمل متد `Object.entries` هست که یه شیء رو به آرایه‌ای از زوج‌های کلید-مقدار تبدیل می‌کنه. این دو متد با هم ابزارهای قدرتمندی برای تبدیل داده‌ها بین قالب‌های مختلف ارائه میدن.
```javascript
const entries = [['a', 1], ['b', 2], ['c', 3]];
const obj = Object.fromEntries(entries);
console.log(obj); // { a: 1, b: 2, c: 3 }
```
> تو این مثال، یه آرایه از زوج‌های کلید-مقدار با استفاده از `Object.fromEntries` به یه شیء تبدیل میشه. این متد برای تبدیل داده‌هایی که به صورت آرایه‌های زوج‌های کلید-مقدار ذخیره شدن به اشیاء، خیلی مفیده.

## ویژگی Well-formed JSON.stringify

### 11. ویژگی Well-formed `JSON.stringify` تو ES9 چطوریه؟
> تو ES9، `JSON.stringify` بهبود پیدا کرد تا همیشه رشته‌های UTF-16 صحیح تولید کنه. قبلاً ممکن بود `JSON.stringify` تو مواجهه با بعضی از کاراکترهای خاص یونیکد، رشته‌هایی ناقص تولید کنه که به درستی پارس نمی‌شدن. این بهبود اطمینان میده که رشته‌های تولید شده توسط `JSON.stringify` همیشه قابل اعتماد و به درستی ساخته شده باشن.
```javascript
const str = '\uD800';
console.log(JSON.stringify(str)); // '"\\ud800"' به جای رشته معیوب
```
> تو این مثال، `JSON.stringify` یه رشته یونیکد معیوب رو به درستی تبدیل کرده و در نتیجه، یه رشته قابل اعتماد و صحیح تولید می‌کنه. این ویژگی برای کار با داده‌های متنی پیچیده و بین‌المللی خیلی مفیده.

## متدهای String.prototype.trimStart و String.prototype.trimEnd

### 12. متدهای `trimStart` و `trimEnd` تو ES9 چیه؟
> تو ES9، متدهای `trimStart` و `trimEnd` به رشته‌ها اضافه شدن تا بتونی به راحتی فاصله‌های خالی از ابتدا یا انتهای یه رشته رو حذف کنی. این متدها نسخه‌های خاص‌تری از متد `trim` هستن که هر دو طرف رشته رو برش می‌داد. حالا می‌تونی برش فضای خالی رو به صورت دقیق‌تر کنترل کنی.
```javascript
const str = '   Hello World!   ';
console.log(str.trimStart()); // 'Hello World!   '
console.log(str.trimEnd()); // '   Hello World!'
```
> تو این مثال، متد `trimStart` فاصله‌های خالی اول و `trimEnd` فاصله‌های خالی آخر رشته رو حذف می‌کنن. این قابلیت بهت اجازه میده تا فاصله‌های خالی غیرضروری رو به صورت هدفمند از رشته‌ها حذف کنی.

## متدهای Array.prototype.flat و Array.prototype.flatMap

### 13. متدهای `flat` و `flatMap` تو ES9 چطوریه؟
> تو ES9، متدهای `flat` و `flatMap` به آرایه‌ها اضافه شدن تا بتونی به راحتی آرایه‌های تو در تو رو تخت کنی یا عملیات خاصی رو روی هر عنصر انجام بدی و بعدش نتیجه رو تخت کنی. این متدها باعث میشن که کدت تو کار با آرایه‌های چندبعدی ساده‌تر بشه.
```javascript
const arr = [1, [2, [3, [4]]]];
console.log(arr.flat(2)); // [1, 2, 3, [4]]

const arr2 = [1, 2, 3];
console.log(arr2.flatMap(x => [x, x * 2])); // [1, 2, 2, 4, 3, 6]
```
> تو این مثال، `flat` یه آرایه دو سطح تو در تو رو به یه سطح تبدیل می‌کنه، در حالی که `flatMap` اول هر عنصر رو به یه آرایه جدید نگاشت می‌کنه و بعدش نتیجه رو تخت می‌کنه. این متدها برای کار با داده‌های پیچیده و چندلایه خیلی مفیدن.
